{"ast":null,"code":"import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\" // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n// or until we implement support for linear() easing.\n// \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nconst sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  const sampleAnimation = new MainThreadAnimation({ ...options,\n    keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  });\n  let state = {\n    done: false,\n    value: keyframes[0]\n  };\n  const pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  let t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nclass AcceleratedAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const {\n      name,\n      motionValue,\n      keyframes\n    } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue);\n    this.resolver.scheduleResolve();\n  }\n\n  initPlayback(keyframes, finalKeyframe) {\n    var _a;\n\n    let {\n      duration = 300,\n      times,\n      ease,\n      type,\n      motionValue,\n      name\n    } = this.options;\n    /**\n     * If element has since been unmounted, return false to indicate\n     * the animation failed to initialised.\n     */\n\n    if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n      return false;\n    }\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n\n\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const {\n        onComplete,\n        onUpdate,\n        motionValue,\n        ...options\n      } = this.options;\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n      keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n      // at least two keyframes to animate between as older browsers\n      // can't animate between a single keyframe.\n\n      if (keyframes.length === 1) {\n        keyframes[1] = keyframes[0];\n      }\n\n      duration = pregeneratedAnimation.duration;\n      times = pregeneratedAnimation.times;\n      ease = pregeneratedAnimation.ease;\n      type = \"keyframes\";\n    }\n\n    const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options,\n      duration,\n      times,\n      ease\n    }); // Override the browser calculated startTime with one synchronised to other JS\n    // and WAAPI animations starting this event loop.\n\n    animation.startTime = time.now();\n\n    if (this.pendingTimeline) {\n      animation.timeline = this.pendingTimeline;\n      this.pendingTimeline = undefined;\n    } else {\n      /**\n       * Prefer the `onfinish` prop as it's more widely supported than\n       * the `finished` promise.\n       *\n       * Here, we synchronously set the provided MotionValue to the end\n       * keyframe. If we didn't, when the WAAPI animation is finished it would\n       * be removed from the element which would then revert to its old styles.\n       */\n      animation.onfinish = () => {\n        const {\n          onComplete\n        } = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n    }\n\n    return {\n      animation,\n      duration,\n      times,\n      type,\n      ease,\n      keyframes: keyframes\n    };\n  }\n\n  get duration() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      duration\n    } = resolved;\n    return millisecondsToSeconds(duration);\n  }\n\n  get time() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      animation\n    } = resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n\n  set time(newTime) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n\n  get speed() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 1;\n    const {\n      animation\n    } = resolved;\n    return animation.playbackRate;\n  }\n\n  set speed(newSpeed) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.playbackRate = newSpeed;\n  }\n\n  get state() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return \"idle\";\n    const {\n      animation\n    } = resolved;\n    return animation.playState;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n\n\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const {\n        resolved\n      } = this;\n      if (!resolved) return noop;\n      const {\n        animation\n      } = resolved;\n      animation.timeline = timeline;\n      animation.onfinish = null;\n    }\n\n    return noop;\n  }\n\n  play() {\n    if (this.isStopped) return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n\n    if (animation.playState === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    animation.play();\n  }\n\n  pause() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.pause();\n  }\n\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\") return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation,\n      keyframes,\n      duration,\n      type,\n      ease,\n      times\n    } = resolved;\n\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n\n\n    if (this.time) {\n      const {\n        motionValue,\n        onUpdate,\n        onComplete,\n        ...options\n      } = this.options;\n      const sampleAnimation = new MainThreadAnimation({ ...options,\n        keyframes,\n        duration,\n        type,\n        ease,\n        times,\n        isGenerator: true\n      });\n      const sampleTime = secondsToMilliseconds(this.time);\n      motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    }\n\n    this.cancel();\n  }\n\n  complete() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.finish();\n  }\n\n  cancel() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.cancel();\n  }\n\n  static supports(options) {\n    const {\n      motionValue,\n      name,\n      repeatDelay,\n      repeatType,\n      damping,\n      type\n    } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n    /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n\n}\n\nexport { AcceleratedAnimation };","map":{"version":3,"names":["time","DOMKeyframesResolver","memo","noop","millisecondsToSeconds","secondsToMilliseconds","BaseAnimation","MainThreadAnimation","animateStyle","isWaapiSupportedEasing","getFinalKeyframe","supportsWaapi","Object","hasOwnProperty","call","Element","prototype","acceleratedValues","Set","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","name","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","isGenerator","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","AcceleratedAnimation","constructor","motionValue","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","initPlayback","_a","owner","current","onComplete","onUpdate","pregeneratedAnimation","length","animation","startTime","now","pendingTimeline","timeline","onfinish","set","cancel","resolveFinishedPromise","resolved","currentTime","newTime","speed","playbackRate","newSpeed","playState","attachTimeline","_resolved","play","isStopped","updateFinishedPromise","pause","stop","sampleTime","setWithVelocity","complete","finish","supports","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"sources":["E:/socket stories/frontend/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (options.type === \"spring\" ||\n        options.name === \"backgroundColor\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = time.now();\n        if (this.pendingTimeline) {\n            animation.timeline = this.pendingTimeline;\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            animation.timeline = timeline;\n            animation.onfinish = null;\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}